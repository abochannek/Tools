#!/usr/bin/env bash

trap time_left USR1
trap ':' USR2 # terminate running pomo/break

buttons='25 min Pomodoro,5 min Break,30 min Break,End'
response=0

function sleep_timer() {
  sleep $1
}

function time_left () {
  finish_time=$(dateutils.dadd -i %s ${start_time} +$((response * 60))s)
  time_left=$(dateutils.ddiff -f%Mm%0Ss now ${finish_time})
  case ${response} in
    25) time_message="${buttons%%,*}" ;;
    5)  time_message=$(awk -F, '{print $2}' <<< "${buttons}") ;;
    30) time_message=$(awk -F, '{print $3}' <<< "${buttons}") ;;
  esac
  time_message+=$'\n\n'
  time_message+="Time Left: ${time_left}"
  time_message+=$'\n\n'
  xmessage -name pomo -title "Pomodoro" -center -timeout 30 "${time_message}"
}

function check_required() {
  if [[ ! -x $(command -v xmessage) ]]; then
    echo "ERROR: $0 requires xmessage"
    exit 128
  fi
  if [[ ! -x $(command -v dateutils.dadd) ]]; then
    echo "ERROR: $0 requires the dateutils package"
    exit 128
  fi
}

function main() {

  let count{25,5,30}=0 # poms, sbreaks, lbreaks
  let terms=0

  if ! xrdb -q | grep -q pomo; then
      xrdb -merge - <<< 'pomo*font: 10x20'
  fi

  while true; do
    message=$'Start Pomodoro\n\nPomodoros:\t\t'
    message+="${count25}"
    message+=$'\nShort breaks:\t\t'
    message+="${count5}"
    message+=$'\nLong breaks:\t\t'
    message+="${count30}"
    message+=$'\n\nEarly terminations:\t'
    message+="${terms}"
    message+=$'\n\n'

    response=$(xmessage -name pomo -title "Pomodoro" -center -print \
                        -buttons "${buttons}" "${message}"|cut -d\  -f1)

    case ${response} in
      25|5|30)
        ((count${response}++))
        start_time=$(date -u +%s)
        coproc sleep_timer $((response * 60))
        ;;
      End)
        grep : <<<"${message}"
        exit
        ;;
    esac

    until wait ${COPROC_PID}; do
      if [[ $? -eq 140 ]]; then # SIGUSR2
        kill ${COPROC_PID}
        ((count${response}--))
        ((terms++))
        break
      fi
    done
  done
}

check_required
main
